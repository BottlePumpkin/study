# Cocoa Internal

## 2장 객체에 대한 메모리 관리

- 메모리는 CPU 사용량, 배터리 소모량에 영향을 준다.

iOS : Mac과 다르게 하드디스크가 없고, 플래시 메모리를 사용한다 ⇒ 메모리 부족

- Read-Only 데이터 : 프로그램 동안 사라지지 않는다
- Read-Write 데이터 : 페이지를 저장하고 메모리에서 지운다

운영체제는 프로세스 주소 공간보다 물리적인 메모리가 상대적으로 부족

⇒ 가상 메모리 방식 

가상메모리 관리 : CPU와 메모리 관리 유닛(MMU)에서 일정한 크기를 가진 페이지(4KB)를 나눠서 메모리를 관리한다. 가상 메모리 페이지 중에 읽은 데이터가 없어서 페이지 실패(Page Fault)가 되면 디스크에서 4KB 단위씩 새 페이지를 읽는다. 이런 과정이 반복 될 수록 앱 성능에 안좋음

![Screen Shot 2021-10-20 at 8.49.39 PM.png](Cocoa%20Internal%208ba332a555eb4fc58b7673f9d477c49c/Screen_Shot_2021-10-20_at_8.49.39_PM.png)

### 2.1.1 객체 인스턴스 생성

' 객체 생명 주기 예측'

+ alloc  ( message) →  class 객체 → malloc 계열 (C 함수) 호출 

객체 메타 클래스에 명시된 속성 데이터 타입 크기를 확인 ClsSizeInstance 크기 만큼 힙 메모리를 할당

이때 메모리의 최소단위는 16Byte다.

4Byte 요청 → 16Byte할당

24Byte 요청 → 32Byte 할당 

 + alloc 메서드

→  + alloc with Zone 호출

→ class_createInstance 런타임 Api 호출

→ calloc 함수를 호출

 malloc과 다르게 객체 크기 만큼 메로리를 할당 할당한 메모리 공간은 0으로 채워 줌

-init(메세지) → Heap(aPen 객체인스턴스) → Pen생성자를 호출 필요한 초기값 설정

생성자 (-init 메서드) : 객체 생성 직후에 호출하여 객체 인스턴스 내부변수를 초기화 하는 중요한 역활을 함!

1. 객체 인터스턴스 메모리 할당
2. 생성자 메서드 호출 (객체 생명주기 시작)
3. 만약 객체 내부에 하위객체가 있다면 생성자에서 하위객체 인스턴스 생성!

- 메모리 할당 단위

[메모리 할당 단위](https://www.notion.so/bc56faf63c684b46a0287d0ecb29fedf)

메모리 조각이 구분없이 만들어지면 작은 공간이 많아도 큰 객체들이 들어 갈 수 없는 파편화가 생김.

이를 방지 하기 위해 힙 메모리 내부에 공간을 Malloc_Nano, Malloc_Tiny,Malloc_Small, Malloc_Large 이렇게 구분하여, 동일한 단위끼리 할당.

- 메모리 영역과 가상 메모리

Megazine_Malloc (OS X 10.6) : 멀티 스레드 환경에서 메모리 영역에 대한 오버헤드를 줄이기 위해 스레트 별로 관리하는 단위

 * 오버헤드 : 시스템 제어 프로그램이 시스템 지원을 위하여 대기하는 시간

TINY 단위 : 스레드 상관없이 최상위 수준에서 생성하고 각기 스레드에 할당하는 구조로 동작

Why? Objc 객체 인스턴스를 TINY단위 크기 보다 작은 크기로 생성한다고 가정!

설계시에 1KB 이하인 TINY영역이나 NANO영역에 들어가도록 만드는 것이 적당

1KB보다 큰 NSData의 경우 Stack에서 처리

 * 힙 공간에는 객체 인스턴스 뿐만 아니라  이미지 리소스나 캐싱된 데이터가 들어가기 때문에 주의가 필요함

### 2.1.2 객체 인스턴스 소멸

소멸자 메서드는 소멸되기 직전에 호출!

객체 인스턴스 → release 메서드 → Framework

      소멸            ← dealloc ←

[dealloc 과 deinit](https://www.notion.so/6ef49ebce6e04a0f910da76d0def4100)

### 2.1.3 요약

커널에서 관리하는 메모리가 늘어남에 따라 지역관리 필요성이 없어졌지만 그럼에도 객체 인스턴스를 생성해서 소멸할 때까지의 과정을 메모리 관리 측면에서 이해하고 있으면 더 효율적인 프로그램을 작성 할 수 있다는 사실!

## 2.2 참조 계산

객체의 생명주기 : 객체 인스턴스가 메모리에 생성되고 소멸되는 과정

참조계산? 

특정 객체가 다른 객체에 존재할 경우 참조할 객체가 메모리에 존재하는지 아니면 사라졌는지에 대한 판단을 하기 위해서 참조 계산 방식을 제공한다!

- 객체 소유권 규칙 (코코아 프레임워크)
1. 특정 객체를 새로 만드는 경우는 소유권을 갖는다 (참조 횟수 +1)
    
    (alloc, new, copy, mutable copy)
    
2. 다른 객체가 생성한 객체를 참조하기 전에 소유권을 요청 해야한다
    
    (retain)
    
3. 소유권을 얻는 객체를 더 이상 참조하지 않으면 소유권을 반환한다. (참조 횟수 -1)
    
    (release, autorelease)
    
4. 소유권을 갖고 있지 않는 객체를 반환하면 안된다.

### 2.2.2 자동 반환 목록

참조 횟수가 0이 되면 dealloc을 바로 호출 함, 근데 메모리에 남겨야 되서 써야 된다면 어떻게하지?

⇒ 자동 반환 목록 : 일정 시간 뒤에 반환할 목록을 만들어줌

객체 인스턴스 → 힙 메모리 저장

변수 → 스택

![Screen Shot 2021-10-20 at 9.35.18 PM.png](Cocoa%20Internal%208ba332a555eb4fc58b7673f9d477c49c/Screen_Shot_2021-10-20_at_9.35.18_PM.png)

- 간편한 메서드와 자동 반환 대상

생성하면서 자동반환 목록을 추가하는 객체가 있는데, NS접두어가 없고, 소문자로 시작함!
NSstring에선 +StringWithFormat 등이 있음.

동작은 동일하나 소유권이 객체에 있는 것이 아니라 자동 반환 목록 (AutoreleasePool)로 넘어감

AutorelasePool은 스레드마다 하나씩 생성해서 소유권을 갖고 있다가 스레드가 끝날 때 같이 소멸하는 것을 권장

앱이 동작하는 메인스레드에 대해서는 따로 만들지 않아도 된다 (main() 내부 함수에 AutorealasePool 객체를 만드는 코드가 있음)

- 자동 반환 목록 사용 시 주의 사항

NSRunLoop 클래스와 같이 사용하는데, 코드 흐름상 반복해서 객체를 생성하면 반환 시점이 되기도 전에 목록에 너무 많이 쌓이는 현상이 생길 수 있음. 

### 2.2.3 객체 그래프

![Screen Shot 2021-10-20 at 9.40.25 PM.png](Cocoa%20Internal%208ba332a555eb4fc58b7673f9d477c49c/Screen_Shot_2021-10-20_at_9.40.25_PM.png)

### 2.2.4 순환 참조 문제

객체 그래프를 그리는 이유는 순환참조 확인

![Screen Shot 2021-10-20 at 9.40.58 PM.png](Cocoa%20Internal%208ba332a555eb4fc58b7673f9d477c49c/Screen_Shot_2021-10-20_at_9.40.58_PM.png)

![Screen Shot 2021-10-20 at 9.41.13 PM.png](Cocoa%20Internal%208ba332a555eb4fc58b7673f9d477c49c/Screen_Shot_2021-10-20_at_9.41.13_PM.png)

### 2.2.5 요약

1. 참조 횟수를 가감
2. 객체 소유권
3. AutoreleasePool
4. 객체 그래프

## 2.3 객체 초기화

NSObject 의 기본 초기화 메서드 (-init)

: 상속 받은 모든객체의 기본  치고화 메서드

### 2.3.1 여러 초기화 메서드

```jsx
-(id) init {
	self = [super init];
	if (self != nil) {
		//인스턴스 변수 초기화
	}
	return self;
}
```

1. 상속 받은 부모 객체의 인스턴스와 내부 변수, 리소스 초기화
2. 자기 자신의 리소스 초기화

 * Instance Type (인스턴스 타입)

id Type을 사용했었는데 타입정보가 부족한 것이 위험 요인이 되어서 Instance Type사용을 권장 한다.

'생성자에서 해당 클래스에 대한 인스턴스를 리턴한다'

### 2.3.2 초기화 메서드 구현하기

1. 상속 받은 슈퍼 클래스의 초기화 메서드 호출
2. 슈퍼 클래스 초기화 메서드 리턴 값이 nil이면 내부 리소스를 초기화 하지않고  nil 리턴
3. 내부 리소스 초기화 객체는 copy,retain 메서드를 호출해서 소유권을 갖는다
4. 인스턴스 변수 → 초기화 → self 리턴
5. 인스턴스 변수 초기화중 Error → realase → self해제
6. self가 아닌 객체 인스턴스를 리턴하는 경우에도 self를 해제 해야함

### 2.3.3 객체 초기화 관련한 문제

- init 초기화 후에 다시 init메서드를 다시 호출 하면 안된다. 이미 초기화 했던 객체를 다시 초기화 하면 exception이 생김.