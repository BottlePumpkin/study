# 1장

객체 중심 운영체제

Next Step ⇒ OS X로 포팅

- Objc 기반 새로만든 맥용 프레임워크 ⇒ Cocoa Framwork
- C 기반 맥 프레임 워크 ⇒ Carbon

iOS용 프레임 워크 (코코아 프레임워크 + Touch)

⇒ 코코아 터치 프레임워크 (Cocoa Touch Framwork)

객체 중심 프로그래밍

(Objected_Oriented_Programming)

⇒ 프로그램 구성하는 단위를 객체 단위로 구분

### 1.1 클래스와 객체 인스턴스

객체 중심 프로그래밍 ↔ 절차 중심 프로그래밍

![Screen Shot 2021-10-28 at 11.50.22 AM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_11.50.22_AM.png)

Simula : 첫 번째 객체 중심 언어 (objects와 class용어 사용)

- class : 추상화해서 만든 코드
- instance: 메모리에 구체화 된 실체

### 1.1.1 객체에 대한 철학

객체(object)라는 단어는 주체(나)를 중심으로 하는 1인칭 시점에 바라 볼 때 세상의 모든 것을 지칭하는 단어!

Objective-C : 객체를 '객관적으로' 바라보고 추상화 시켜 표현하기 위한 언어

### 1.1.2 객체 중심 프로그래밍

랑그(개념) : '논리적인 사고'를 만들어진 알고리즘

파롤(구현): '컴퓨터 프로그래밍 언어로 코드 작성

절차 중심 프로그래밍 - 프로그램이 동작하는 순서

객체 중심 프로그래밍 - 실생활에서 사고하는 방식과 비슷한 객체 개념

알고리즘을 프로그래밍 언어 코드로 작성 = 개발자 머릿속에 있는 생각들을 글로 표현하는 과정

![Screen Shot 2021-10-28 at 4.39.44 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_4.39.44_PM.png)

- 로버트 마틴 (SOLID)

: 클래스코드를 작성 할 때, 명확하고 깔끔한 책임 구조와 높은 응집력, 낮은 의존성, 변화에 대한 유용성 등을 고려할 것을 권장.

### 1.1.3 오브젝티브-C 객체

오브젝티브-C를 만든 브래드 콕스는 객체를 소프트 웨어 IC에 비유

소프트웨어도 하드웨어와 마찬가지로 부품처럼 부품화 해야 한다!

 클래스 메서드 : + 로 시작하는 메서드

 인스턴스 메서드: -로 시작하는 메서드

@Interface(헤더 파일 내부 인터페이스) 영역에 선언한 메서드만 객체 외부에서 접근 할 수 있다.

@implementation (구현) 영역에 선언한 메서드는 내부에서만 접근, 외부로는 감춰진다.

캡슐화 : 객체 내부 데이터드는 감춰서 직접 접근 할 수 없도록 하고, 객체 외부에서 접근 가능한 메서드를 인터페이스로 제공 하는 방식.

### 클래스 명세와 객체 인스턴스

- 팩토리 메서드 (Factory Method)

: Pen 객체 인스턴스를 생성,  오브젝티브-C의 대부분 클래스는 클래스 설계 명세를 기준으로 객체 인스턴스를 생성하는 공장 역활을 한다.

![Screen Shot 2021-10-28 at 4.48.26 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_4.48.26_PM.png)

1. Pen 클래스에 코드를 공유한다. 

⇒ 다른 인스턴스와는 구분되는 고유한 데이터를 포함. Isa 포인터로 자신을 추상화 한 Pen클래스를 가리킴.

1. 모든 객체가 공유

⇒ 클래스 명세를 기준으로 만들어진 각각의 객체 인스턴스가 클래스 코드를 재사용

☝🏽포인터(Pointer)

프로그래밍 언어에서 다른 변수, 혹은 그 메모리 공간 주소를 가리키는 변수. 

역참조 : 포인터가 가리키는 값을 가져오는 것

### 1.1.4 오브젝티브-C 2.0 이후 변화

1. isa 접근이 불가능 → 객체의 클래스(메세지) → NsObject class → 런타임 api object_get_class
2. 최신 버전 런타임 사용 (클래스 인스턴스 변수구조가 바뀌면, 반드시 새로 컴파일 해야했었던 방식에서 변화)

### 1.1.5 스위프트 네이티브 객체

스위프트 class 객체

1. objc와 호환
2. 네이티브 객체 (objc 호환 X)

스위프트 컴파일러가 만드는 스위프트 중간 언어 (SIL) 코드조각

- 스위프트 네이티브 객체 : 생성 함수와 소멸 함수

생성 함수 init() → *TFC5class9NativePencft_s0_*

소멸 함수 deinit → TFC5class9NativePend

- name Manging(이름 변형) : 컴파일러가 함수이름이나 데이터 구조이름을 바꾸는 규칙 ⇒ 함수이름이나 데이터 구조 이름과 함께 입출력타입까지 포함해서 고유하게 구분 하기 위함

스위프트 네이티브 객체는 최상위 객체이며, 다른 클래스를 지정하지 않아도

생성을 위해서 allocating_init(), init() 함수를 만들고, 소멸을 위해서 deallocating_deinit()과 deinit()함수를 만든다.

Objc에서는 객체 인스턴스 메모리 할당을 위한 +alloc 메서드와 초기값을 설정하는 -init메서드가 나눠져 있지만 스위프트 네이티브 객체에서는 allocating_init() 함수에서 alloc_ref()함수를 통해 메모리를 할당하고 곧바로 init() 메서드를 호출해서 객체 인스턴스 내부 id와 sequence 변수를 초기화 함.

![Screen Shot 2021-10-28 at 5.17.02 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_5.17.02_PM.png)

- 스위프트 중간 언어 (SIL)

스위프트 컴파일러 (swiftc): 스위프트로 작성한 코드 파일을 읽는다.

→ 스위프트 중간언어 (SIL)로 만든다

→ LVVM IR로 변환

→ LVVM IR 최적화 기

→ 기계코드 생성(MC)

![Screen Shot 2021-10-28 at 5.16.51 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_5.16.51_PM.png)

'

- 스위프트 네이티브 객체 : getter / setter 함수

let 선언: id 변수는 값을 변경 할 수 없음 ⇒ setter만 있고 getter는 없다.

var 선언:

materializeForSet() 함수는 var로 선언한 변수에 대한 초기값을 바로 할당하지 않는다

⇒ 계산하는 속성(computed property)이나 내부함수에서 늦게(lazy) 초기 값을 설정하는 경우에 널 값에 대한 예외처리 (옵셔널 처리)를 하여 안전하게 값을 설정할때 사용 된다.

- 스위프트 오브젝티브-C 호환 객체

Objc코드에서 스위프트 객체를 사용하려면, 해당 스위프트 객체는 반드시 NSObject를 최상위 클래스로 지정하고 상속 받아야 함.

Objc 최상위 객체를 상속 받은 경우, 스위프트 객체는 내부에서 다음과 같은 Objc 객체로 자동 변환하고 Objc 런타임에서 동작한다.

스위프트 네이티브 객체와 다른점

: deinit()에 해당하는 소멸 함수가 없다

⇒ deallocating_deinit() 함수에서는 NSObject.deinit() 메서드를 호출

⇒ init()함수에서는 alloc_box()함수로 객체 레퍼런스를 만들어서 내부 변수를 초기화 된다.

@objc (호환성 함수) 

## 1.2 객체의 등가성

### 1.2.1 오브젝티브-C 객체와 메모리 구조

![Screen Shot 2021-10-28 at 5.28.19 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_5.28.19_PM.png)

- 가상 메모리 배치 구조

객체 인스턴스 힙HEAP영역에 만들어지며, 해당 메모리 주소를 스택STACK영역에 할당한 포인터로 참조해서 접근한다.

### 

![Screen Shot 2021-10-28 at 5.30.28 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_5.30.28_PM.png)

- 클래스 객체 생성하기
1. +new  메서드 하나 호출
2. 1. +alloc, -init 메서드 

-init 메서드로 아무 인자 값을 넘기지 않고 초기화하는 경우, 코드 양을 줄이기 위해 +new 사용

### 1.2.2 객체 정체성

![Screen Shot 2021-10-28 at 5.36.13 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_5.36.13_PM.png)

aPen,bPen 객체는 서로 다른 객체이며 고유한 정체성을 갖는다!

- 동일한 객체 정체성

이때 bPen = aPen; 코드를 추가하면 bPen 포인터 변수가 저장하고 있던 주소 대신 aPen 메모리 주소가 bPen에 동일하게 저장 된다.

- 객체 등가성

동일한 속성을 가진 객체 인스턴스여도 고유한 메모리 영역을 가지고 있다!

⇒ 객체 등가성을 갖는다

객체 등가성을 가진 객체를 비교하려면 '='로 비교하는 것이 아니라 isEqual로 비교 해야 한다. 두 객체의 인스턴스 모든 속성이 동일 해야 등가성을 갖는다.

### 1.2.4 객체 예외성

힙 영역이 아니라 텍스트 영역과 데이터 영역에 생기는 객체 인스턴스가 있다?

NSString : NSObject를 상속받는 코코아 클래스 중에서 유일하게 전역 변수로 선언 할 수있음! 힙 영역이 아니라 텍스트 영역에 값을 저장하고 변수는 전역 변수 형태로 데이터 영역에 만들어 진다!

aPenName = "bluePen"

bPenName = "bluePen"

같은 텍스트 영역을 사용하고 bPenName 객체 인스턴스를 전역변수로 할당!

두개는 동일한 정체성을 갖는다. ⇒ 문자열 이터닝(String interning)

![Screen Shot 2021-10-28 at 5.41.54 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_5.41.54_PM.png)

- 스위프트 문자열

String이 NSString보다 가벼운 형태임

String : 텍스트 영역의 문자열 OpaquePointer 형태 포인터 그대로 연결하는 방식

### 1.2.5 -hash 메서드

NSDictionary : -hash 메서드 사용해서 비교

-hash 메서드

: 정체성 기준이 되는 self 메모리 포인터 값을 NSInteger 타입 숫자로 변환

객체 정체성이 다르지만 등가성이 성립하는 경우를 위해서 결과값이 고유!

모든 속성에 대해 해시값을 고민 해야함.

- 스위프트 Hashble 프로토콜

: 객체 뿐만 아니라 모든 타입에 Hashable 프로토콜을 구현

## 1.3 객체 사이 관계

- 객체 중심 프로그래밍?

나를 기준으로 1인칭 시점에서 사물을 객관적으로 분석하고 분류

프로그래밍한 객체들도 현실 세계 사물의 간계처럼 다양한 관계를 가짐

### 1.3.1 메타 클래스

![Screen Shot 2021-10-28 at 5.49.33 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_5.49.33_PM.png)

aPen객체 인스턴의 isa 포인터는 Pen클래스를 가리키고 있다

aPen 객체에 메세지를 보내면 Pen클래스에 있는 인서턴스 메서드 중에서 해당 셀렉터에 해당하는 메서드를 찾아서 실행함.

[ Pen new ] 처럼 클래스에 메세지를 보내면 Pen클래스 isa 포인터가 가리키는 메타 클래스에서 클래스 메서드를 찾아서 실행 함. 

Pen 클래스는 인스턴스 메서드 목록과 코드를 가지고 있다

Pen 클래스의 메타 클래스는 클래스 메서드 목록과 코드를 가지고 있다.

### 1.3.2 상속

캡슐화,상속,다형성,추상화한 클래스 명세,객체 인스턴스의 활용

상속 : 객체 사이 관계와 밀접한 특징

최상위 클래스에 가장 일반화 된 속성과 특징을 추상화하고 하위 클래스들은 상위 클래스를 상속받아 더 구체화 한다!

![Screen Shot 2021-10-28 at 5.56.03 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_5.56.03_PM.png)

### 1.3.3 is-a 관계와 has-a 관계

- is-a 관계
1. 객체 인스턴스와 클래스 관계
2. 서브 클래스와 슈퍼 클래스 상속 관계

Objc

1. isa : 객체 인스턴스와 클래스의 관계
2. super: 서브클래스와 슈퍼 클래스의 관계

- has-a 관계
1. composition(구성 관계) : 강한 참조 결합성

→ 사라 질때 하위 객체도 같이 사라짐. 참조하는 객체와 하위 객체가 동일한 생명 주기를 갖는다. (ARC Strong)

1. aggregation(집합 관계) : 약한 참조 결합성

→ 객체가 사라지더라도 하위객체는 사라지지 않음 (ARC Weak)

### 1.4 오브젝티브-C 런타임 (C 함수 라이브러리)

클래스와 메타 클래스 메모리에 로딩하는 역활

→ 메시지 처리, 메세지 찾기, 객체 메모리 관리, 동적 타입 변환

### 1.4.1 기존 런타임과 최신 런타임

최신 런타임 : Objc 2.0 프로퍼티, 빠른 검색, ARC, 블록 기능

### 1.4.2 메시지 디스패치

Objc 객체의 메서드 직접호출하지않고 객체에 메시지를 보내는 방식으로 동작

![Screen Shot 2021-10-28 at 6.00.59 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_6.00.59_PM.png)

![Screen Shot 2021-10-28 at 6.01.10 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_6.01.10_PM.png)

![Screen Shot 2021-10-28 at 6.01.30 PM.png](1%E1%84%8C%E1%85%A1%E1%86%BC%20baebfa8ec1d84632acac7d364688403c/Screen_Shot_2021-10-28_at_6.01.30_PM.png)